<!DOCTYPE html>
<!--[if IE 9]>
<html class="lt-ie10" lang="en" prefix="og: http://ogp.me/ns#"> <![endif]-->
<html class="no-js" lang="en" prefix="og: http://ogp.me/ns#">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    


  <title>Data  definiendo nuestros tipos en haskell</title>
  <meta property="og:title" content="Data  definiendo nuestros tipos en haskell" />






<link rel="canonical" href="wiki.uqbar.org/wiki/articles/data--definiendo-nuestros-tipos-en-haskell.html" />
<meta property="og:url" content="wiki.uqbar.org/wiki/articles/data--definiendo-nuestros-tipos-en-haskell.html" />
<meta property="og:site_name" content="uqbar-wiki" />
<meta name="application-name" content="uqbar-wiki"/>

<meta property="og:updated_time" content=" 2025-07-10T21:15:21-03:00" />






  <meta property="keywords" content="" />











    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" >
    <link type="text/plain" rel="author" href="/humans.txt"/>
    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Nunito&display=swap" rel="stylesheet">    

    <link rel="stylesheet" href="/assets/app-1e946f931f577cd478e6e6610915be9d.css">
    <style>
        .navbar {
            -webkit-backface-visibility: hidden;
        }
    </style>
</head>

<body>

<nav class="top-bar navbar-background" data-topbar>
    <ul class="title-area">
        <li class="name">
            <div id="pagetitle"><img alt="Uqbar" src="/img/proyecto-uqbarwiki.png" height="100px"
                    width="100px" /></div>
        </li>
    </ul>
    <ul class="left">
        <div class="mobile">
            <div class="navbar-buttons">
                <div class="navbar-icon-link">
                    <a href="/"><img alt="Home" src="/img/wiki/home-2.png" height="25px"
                            width="25px" title="Home" /></a>
                </div>
                <div class="navbar-icon-link">
                    <a href="/articles"><img alt="Artículos" src="/img/wiki/list.png"
                            height="25px" width="25px" title="Artículos" /></a>
                </div>
            </div>
        </div>
    </ul>
</nav>

<div class="column small-0 medium-2 large-2 sidebar" style="margin-top: 5px;">
        <!-- Html Elements for Search -->
<div id="search-container">
    <input type="text" id="search-input" name="search-input" placeholder="Artículo a buscar...">
    <ul id="results-container"></ul>
    <hr>
</div>

        <div class="not-mobile">
                <ul class="rows small-12 medium-10 large-10 side-nav stack button-group" title="Links" role="menu">
                        <li class="button" role="menuitem"><a href="/" class="sidebar-link"><img
                                                alt="Home" src="/img/wiki/home-2.png" height="35px"
                                                width="35px" />&nbsp;&nbsp;&nbsp;Home</a></li>
                        <li class="button" role="menuitem"><a href="/articles" class="sidebar-link"><img
                                                alt="Artículos" src="/img/wiki/list.png" height="35px"
                                                width="35px" />&nbsp;&nbsp;&nbsp;Artículos</a></li>
                </ul>

                <hr>

                <ul class="rows small-12 medium-10 large-10 side-nav stack button-group" role="menu">
                        <img src="/img/wiki/utn.png" alt="UTN" height="40px" width="40px" title="UTN" />
                        <li class="button" role="menuitem"><a
                                        href="/wiki/articles/paradigmas-de-programacion.html">Paradigmas
                                        de
                                        programación</a></li>
                        <li class="button" role="menuitem"><a href="/wiki/articles/design-temario.html">Diseño de
                                        Sistemas</a>
                        </li>
                        <li class="button" role="menuitem"><a
                                        href="/wiki/articles/tecnicas-avanzadas-de-programacion.html">Técnicas
                                        avanzadas de programación</a></li>
                        <br>
                        <img src="/img/wiki/unsam.png" alt="UNSAM" height="40px" width="40px"
                                title="UNSAM" />
                        <li class="button" role="menuitem"><a href="/wiki/articles/algo2-temario.html">Algoritmos
                                        II</a></li>
                        <li class="button" role="menuitem"><a href="/wiki/articles/algo3-temario.html">Algoritmos
                                        III</a></li>
                        <li class="button" role="menuitem"><a href="/wiki/articles/phm-temario.html">Programación
                                        con
                                        Herramientas
                                        Modernas</a></li>
                </ul>
        </div>
</div>

<div class="column small-12 medium-10 large-10">
    <div id="article_title">
    <h1>
        <i>Data  definiendo nuestros tipos en haskell</i>
    </h1>
</div>



<div id="article_content">
    <div id="toc-container">
  <table class="toc" id="toc">
    <tbody>
      <tr>
        <td>
          <div id="toctitle">
            <h2>Contents</h2>
          </div>
          <ul>
            <li class="toc_level-1 toc_section-1">
              <a href="#tocAnchor-1-1"><span class="tocnumber">1</span> <span class="toctext">Data: qué es y para qué sirve</span></a>
              <ul>
                <li class="toc_level-2 toc_section-2">
                  <a href="#tocAnchor-1-1-1"><span class="tocnumber">1.1</span> <span class="toctext">Tuplas tuplas tuplas</span></a>
                </li>
                <li class="toc_level-2 toc_section-3">
                  <a href="#tocAnchor-1-1-2"><span class="tocnumber">1.2</span> <span class="toctext">Definiendo nuevos tipos</span></a>
                </li>
                <li class="toc_level-2 toc_section-4">
                  <a href="#tocAnchor-1-1-3"><span class="tocnumber">1.3</span> <span class="toctext">Derivar typeclasses</span></a>
                </li>
              </ul>
            </li>
            <li class="toc_level-1 toc_section-5">
              <a href="#tocAnchor-1-5"><span class="tocnumber">2</span> <span class="toctext">Data con Record Syntax</span></a>
            </li>
            <li class="toc_level-1 toc_section-6">
              <a href="#tocAnchor-1-6"><span class="tocnumber">3</span> <span class="toctext">Cómo instanciar una typeclass</span></a>
            </li>
            <li class="toc_level-1 toc_section-7">
              <a href="#tocAnchor-1-7"><span class="tocnumber">4</span> <span class="toctext">Múltiples constructores por tipo</span></a>
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>
</div><h1 id="tocAnchor-1-1">Data: qué es y para qué sirve</h1>

<p>Usamos data para definir un nuevo tipo de dato, por ejemplo si quisiéramos definir el tipo Booleano escribiríamos</p>

<pre>
  <code class="language-Haskell">data Booleano = &lt;...&gt; 
</code>
</pre>

<table>
  <tbody>
    <tr>
      <td>Qué vamos a escribir en &lt;…&gt;? los posibles valores que tiene ese tipo separados por un pipe (</td>
      <td>)</td>
    </tr>
  </tbody>
</table>

<pre>
  <code class="language-Haskell">data Booleano = Falso | Verdadero
</code>
</pre>

<p>Con esta notación podríamos pensar que el tipo Int está escrito de la siguiente manera</p>

<pre>
  <code class="language-Haskell">data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647  
</code>
</pre>

<p>
  <strong>Nota: Int no está definido de esta manera pero sirve para entender el uso de data</strong>
</p>

<p>Si quisiéramos escribir el tipo ColorPrimario cuales serían sus posibles valores?</p>

<pre>
  <code class="language-Haskell">data ColorPrimario = Rojo | Amarillo | Azul
</code>
</pre>

<p>Si luego quisiéramos hacer una función combinar que reciba dos colores primarios distintos y me retorne un color secundario (Naranja, Violeta o Verde), podemos resolverlo usando <a href="pattern-matching-en-haskell.html">pattern matching</a>:</p>

<pre>
  <code class="language-Haskell">data ColorSecundario = Naranja | Violeta | Verde 

combinar :: ColorPrimario -&gt; ColorPrimario -&gt; ColorSecundario
combinar Rojo Amarillo = Naranja
combinar Amarillo Rojo = Naranja
combinar Rojo Azul = Violeta
combinar Azul Rojo = Violeta
combinar Amarillo Azul = Verde
combinar Azul Amarillo = Verde
</code>
</pre>

<p>Cabe mencionar que esto mismo de los colores lo podríamos haber hecho con Strings, pero haberlo hecho con data limita los valores posibles a aquellas cosas que consideramos válidas para el tipo específico que queremos representar.</p>

<h2 id="tocAnchor-1-1-1">Tuplas tuplas tuplas</h2>

<p>Una forma de representar valores que están compuestos por otros valores, tal que cada uno de ellos tiene una semántica distinta, es usando uno de los <a href="tipos-de-haskell.html">tipos compuestos bien conocidos de Haskell, las tuplas</a>.</p>

<p>Vamos a hacer un ejemplo con tuplas de 2 elementos por simplicidad, pero lo mismo se aplica para tuplas de n elementos. Supongamos que queremos armar un programa en el cual queremos representar un alumno por su nombre (un String) y sus notas (una lista de Int = [Int]) y también queremos representar una película por su título (unString) y los puntajes que le ponen los críticos en imdb (una lista de Int = [Int]). Por ejemplo:</p>

<pre>
  <code class="language-Haskell">cursoK9 = [("Federico",[2,3]),("Líder",[10,10,10,10,10]),("Germain",[8,9,10])]
pelis = [("Pedornia", [0,0,-3,-666]),("Pulp Fiction", [9,10,9]),("Fight Club", [3,8,8,9,9,10])]
</code>
</pre>

<p>Vamos a agregar además algunas funciones básicas para interactuar con alumnos y películas fácilmente:</p>

<pre>
  <code class="language-Haskell">nombreAlumno unAlumno = fst unAlumno
notasAlumno unAlumno = snd unAlumno
tituloPelicula unaPelicula = fst unaPelicula
puntajesPelicula unaPelicula = snd unaPelicula
</code>
</pre>

<p>Y una de las cosas que queremos hacer con los alumnos es saber si empezó mal (si su primer nota no está aprobada):</p>

<pre>
  <code class="language-Haskell">empezoMal = not . aprobada . head . notasAlumno
aprobada nota = nota &gt;= 6
</code>
</pre>

<p>Si usamos lo que definimos arriba como un solo programa (un solo .hs), podemos ver que:</p>

<ul>
  <li>La función nombreAlumno es igual a la función tituloPelicula</li>
  <li>La función notasAlumno es igual a la función puntajesPelicula</li>
</ul>

<p>Nada me impide consultar:</p>

<pre>
  <code class="language-Haskell">&gt; puntajesPelicula ("Líder",[10,10,10,10,10])
[10,10,10,10,10]

&gt; empezoMal (head pelis)
True
</code>
</pre>

<p>Todo esto es posible porque si miramos los <a href="inferencia-de-tipos.html">tipos que infiere Haskell</a> no existe diferencia entre una película y un alumno, para Haskell los alumnos y películas son sólo tuplas de 2 elementos. Ejemplo:</p>

<pre>
  <code class="language-Haskell">&gt; puntajesPelicula ([1,2,3],(True,"hola"))
(True,"hola")
</code>
</pre>

<p>Si definimos un <a href="tipos-de-haskell.html">alias de tipo</a> para Alumno y Pelicula de esta forma:</p>
<pre>
  <code class="language-Haskell">type Alumno = (String, [Int])
type Pelicula = (String, [Int])
</code>
</pre>

<p>Y luego restringimos los tipos de todas las funciones para explicitar que lo que reciben son alumnos o películas según corresponda:</p>
<pre>
  <code class="language-Haskell">nombreAlumno :: Alumno -&gt; String
nombreAlumno unAlumno = fst unAlumno
notasAlumno :: Alumno -&gt; [Int]
notasAlumno unAlumno = snd unAlumno

tituloPelicula :: Pelicula -&gt; String
tituloPelicula unaPelicula = fst unaPelicula
puntajesPelicula :: Pelicula -&gt; [Int]
puntajesPelicula unaPelicula = snd unaPelicula

empezoMal :: Alumno -&gt; Bool
empezoMal = not . aprobada . head . notasAlumno
</code>
</pre>

<p>De lo único que nos salvamos es de consultas como:</p>
<pre>
  <code class="language-Haskell">&gt; puntajesPelicula ([1,2,3],(True,"hola"))
</code>
</pre>
<p>Porque esa tupla contiene elementos de tipos que no coinciden con los explicitados. Pero esta otra consulta no se ve afectada por el cambio que realizamos, porque tanto Alumno como Pelicula no son más que <code class="language-plaintext highlighter-rouge">(String, [Int])</code>:</p>
<pre>
  <code class="language-Haskell">&gt; empezoMal (head pelis)
True
</code>
</pre>

<p>Ya que Haskell es un lenguaje “que se fija mucho en los tipos”, nos gustaría que un caso como los de arriba nos tirará error (donde en vez de mandar un alumno o una película según corresponda, enviamos cualquier otra cosa incluyendo un alumno donde se esperaba una película y visceversa).</p>

<h2 id="tocAnchor-1-1-2">Definiendo nuevos tipos</h2>

<p>Para poder diferenciar a un alumno de una película y a ambos de una tupla, tenemos que definir un nuevo tipo. Eso se hace usando data:</p>

<pre>
  <code class="language-Haskell">data NuevoTipo = Constructor Tipo1 Tipo2 ... Tipon
</code>
</pre>

<p>
  <strong>Nota: el tipo y el constructor pueden llamarse igual, usaremos nombres distintos a fines didácticos para remarcar en qué contextos lo que usamos es el constructor y en cuáles el tipo.</strong>
</p>

<p>En nuestro ejemplo:</p>

<pre>
  <code class="language-Haskell">data Alumno = UnAlumno String [Int]
data Pelicula = UnaPelicula String [Int]
</code>
</pre>

<p>Ahora, para obtener un nuevo alumno o una nueva película, tenemos que usar el “Constructor”</p>

<pre>
  <code class="language-Haskell">cursoK9 = [UnAlumno "Federico" [2,3], UnAlumno "Líder" [10,10,10,10,10], UnAlumno "Germain" [8,9,10]]
</code>
</pre>

<pre>
  <code class="language-Haskell">-- No cambia
empezoMal unAlumno = 4 &gt; head (notasAlumno unoAlumno)
</code>
</pre>

<pre>
  <code class="language-Haskell">pelis = [UnaPelicula "Pedornia" [0,0,-3,-666], UnaPelicula "Pulp Fiction" [9,10,9], UnaPelicula "Fight Club" [8,8,8,9,9,10]]
</code>
</pre>

<pre>
  <code class="language-Haskell">-- Ahora estas funciones usan Pattern-Matching!
nombreAlumno (UnAlumno nombre notas) = nombre 
notasAlumno (UnAlumno nombre notas) = notas
tituloPelicula (UnaPelicula nombre notas) = nombre
puntajesPelicula (UnaPelicula nombre notas) = notas
</code>
</pre>

<p>Es importante remarcar que al hacer esto un alumno o una película <strong>YA NO ES UNA TUPLA</strong></p>

<pre>
  <code class="language-Haskell">fst :: (a,b) -&gt; a
nombreAlumno :: Alumno -&gt; String
tituloPelicula :: Pelicula -&gt; String
snd :: (a,b) -&gt; b
notasAlumno :: Alumno -&gt; [Int]
puntajesPelicula :: Pelicula -&gt; [Int]
</code>
</pre>

<pre>
  <code class="language-Haskell">cursoK9 :: [ Alumno ]
empezoMal :: Alumno -&gt; Bool
</code>
</pre>

<pre>
  <code class="language-Haskell">pelis :: [ Pelicula ]
</code>
</pre>

<p>Ejemplos:</p>

<p>A partir de estos valores:</p>
<pre>
  <code class="language-Haskell">fede = UnAlumno "Federico" [2,3]
ger = UnAlumno "Germain" [8,9,10]
pulp = UnaPelicula "Pulp Fiction" [9,10,9]
</code>
</pre>

<p>Veamos qué sucede al hacer algunas consultas sobre funciones que esperan tuplas, alumnos o películas.</p>
<pre>
  <code class="language-Haskell">&gt; fst fede
Error (fst espera una tupla y fede es de tipo Alumno)
&gt; nombreAlumno fede
"Federico"
&gt; nombreAlumno pulp
Error (nombreAlumno espera algo de tipo Alumno y pulp es de tipo Pelicula)
&gt; puntajesPelicula fede
Error (puntajesPelicula espera Pelicula y fede es de tipo Alumno)
&gt; puntajesPelicula pulp
[9,10,9]
&gt; empezoMal fede
True
&gt; empezoMal (head pelis)
Error (empezoMal espera Alumno y el primer elemento de pelis es de tipo Pelicula)
</code>
</pre>

<h2 id="tocAnchor-1-1-3">Derivar typeclasses</h2>

<p>Es muy común querer comparar por igualdad y mostrar por pantalla un valor que tiene un tipo definido por nosotros.</p>

<pre>
  <code class="language-Haskell">&gt; head cursoK9
Error (Alumno no tiene la restricción Show)
</code>
</pre>

<p>Para que esto funcione deberíamos:</p>

<ul>
  <li>Decir que Alumno es un tipo que pertenece a la restricción <a href="typeclasses.html">Show</a></li>
  <li>Definir la función show para un Alumno</li>
</ul>

<p>En vez de hacer esto a mano (agregando una instancia de la typeclass como se explica más adelante), y gracias a que los elementos que forman un Alumno SI tienen la restricción Show, podemos hacer que el Alumno “derive” esa restricción</p>

<pre>
  <code class="language-Haskell">--Lo único que hay que agregar es deriving (Show)
data Alumno = UnAlumno String [Int] deriving (Show)
</code>
</pre>

<p>Con este agregado podemos hacer</p>

<pre>
  <code class="language-Haskell">&gt; head cursoK9
UnAlumno "Federico" [2,3]
</code>
</pre>

<p>Ahora, si hacemos lo siguiente</p>

<pre>
  <code class="language-Haskell">&gt; fede == ger
Error (el Alumno no tiene la restricción Eq)
</code>
</pre>

<p>También parece común querer preguntar si dos alumnos son iguales (o distintos), pasa lo mismo que con Show, nos gustaría que el Alumno pertenezca a la typeclass Eq.</p>

<pre>
  <code class="language-Haskell">--Lo único que hay que agregar es deriving (Show,Eq)
data Alumno = UnAlumno String [Int] deriving (Show,Eq)
</code>
</pre>

<p>Con este agregado podemos hacer:</p>

<pre>
  <code class="language-Haskell">&gt; fede == ger
False
&gt; UnAlumno "Roberto" [7,8,9] == UnAlumno "Huberto" [7,8,9]
False
&gt; UnAlumno "Roberto" [7,8,9] == UnAlumno "Roberto" [7,8,9]
True
</code>
</pre>

<p>También se puede utilizar el deriving con la clase Ord</p>

<pre>
  <code class="language-Haskell">data Nota = Insuficiente | Regular | Bien | MuyBien
</code>
</pre>

<p>Al hacer:</p>

<pre>
  <code class="language-Haskell">Main&gt; Insuficiente &gt; Regular
ERROR: No instance for (Ord Nota)
</code>
</pre>

<p>Esto se debe a que el tipo Nota no cumple con la restricción Ord, por defecto se considera a los valores en forma ascendente de izquierda a derecha (i.e. Insuficiente &lt; Regular &lt; Bien &lt; MuyBien).</p>

<p>Para obtener este comportamiento en los valores del tipo Nota lo único que debemos hacer es “derivar” la restricción Ord</p>

<pre>
  <code class="language-Haskell">data Nota = Insuficiente | Regular | Bien | MuyBien deriving Ord
</code>
</pre>

<pre>
  <code class="language-Haskell">Main&gt; Insuficiente &gt; Regular
False
</code>
</pre>

<p>Lo mismo podría hacerse con los tipos ColorPrimario y ColorSecundario definidos anteriormente en este artículo. De seguro vamos a querer que puedan mostrarse. Con derivar Show para ColorSecundario sería suficiente para poder usar la función <code class="language-plaintext highlighter-rouge">combinar :: ColorPrimario -&gt; ColorPrimario -&gt; ColorSecundario</code> desde la consola y ver el resultado, pero a su vez poder ver los colores primarios suena como algo deseable.</p>

<p>También podemos sacarle provecho a derivar Eq, lo que nos permitirá llegar a esta nueva solución sin repetición de lógica:</p>
<pre>
  <code class="language-Haskell">data ColorPrimario = Rojo | Amarillo | Azul deriving (Show, Eq)
data ColorSecundario = Naranja | Violeta | Verde deriving (Show, Eq)

combinar :: ColorPrimario -&gt; ColorPrimario -&gt; ColorSecundario
combinar Rojo Amarillo = Naranja
combinar Rojo Azul = Violeta
combinar Amarillo Azul = Verde
combinar color1 color2 | color1 /= color2 = combinar color2 color1
</code>
</pre>

<h1 id="tocAnchor-1-5">Data con Record Syntax</h1>

<p>Es muy común hacer funciones para obtener los valores que forman nuestro individuo compuesto como hicimos con las películas y los alumnos.</p>

<p>Imaginen que ahora queremos agregarle a nuestro tipo Pelicula (además del nombre y sus puntajes), el nombre del director, el nombre de los actores principales y el año en que se estrenó.</p>

<pre>
  <code class="language-Haskell">data Pelicula = UnaPelicula String String [String] Int [Int]
</code>
</pre>

<p>Lo primero que notamos es que no es tan fácil identificar cada elemento. Para eso existe la posibilidad de declarar sinónimos de tipo usando <a href="tipos-de-haskell.html">type</a>. En el ejemplo de las películas podemos hacer algo como:</p>

<pre>
  <code class="language-Haskell">type Titulo = String
type NombreDirector = String
type Puntajes = [Int]

data Pelicula = UnaPelicula Titulo NombreDirector [String] Int Puntajes deriving (Show,Eq)

narnia = UnaPelicula "Pedornia" "Andrew Adamson" ["Tilda Swinton", "Georgie Henley","William Moseley"] 2005 [0,0,-3,-666]
pulp = UnaPelicula "Pulp Fiction" "Quentin Tarantino" ["John Travolta", "Uma Thurman", "Samuel L. Jackson"] 1994 [9,10,9]
fc = UnaPelicula "Fight Club" "David Fincher" ["Brad Pitt", "Edward Norton", "Helena Bonham Carter"] 1999 [8,8,8,9,9,10]
</code>
</pre>

<p>Lo cual mejora un poco la expresividad de la definición. Igualmente a la hora de construir el dato tenemos que tener cuidado de no pasar primero el nombre del director y luego el título, porque al fin y al cabo los dos son de tipo String, y por ende va a tipar una construcción incorrecta en base a nuestro dominio.</p>

<p>Otro tema es que tenemos que definir nuevamente funciones como tituloPelicula y puntajesPelicula:</p>

<pre>
  <code class="language-Haskell">tituloPelicula (UnaPelicula nombre director actores anioEstreno notas ) = nombre
puntajesPelicula (UnaPelicula nombre director actores anioEstreno notas ) = notas
</code>
</pre>

<p>Como en cualquier otro programa, las variables que no nos interesan en absoluto pueden ser reemplazadas por la variable anónima</p>

<pre>
  <code class="language-Haskell">tituloPelicula (UnaPelicula nombre _ _ _ _ ) = nombre
puntajesPelicula (UnaPelicula _ _ _ _ notas ) = notas
</code>
</pre>

<p>Lógicamente también tenemos que definir funciones para el resto de los campos que antes no existían:</p>
<pre>
  <code class="language-Haskell">directorPelicula (UnaPelicula _ director _ _ _ ) = director
actores (UnaPelicula _ _ actores _ _ ) = actores
anioEstreno (UnaPelicula _ _ _ anio _ ) = anio
</code>
</pre>

<p>Una forma más rápida de definir este tipo de funciones es usando <strong>la sintaxis de registro</strong> (disponible en GHC, no en Hugs).</p>

<p>En vez de definir sólo los tipos de los valores que van a estar en la película, también agregamos en la definición el nombre de la función por el cual queremos obtener dicho valor.</p>

<p>Al utilizar la notación de registro hay que definir los campos que lo componen de una forma distinta, tenemos que:</p>
<ul>
  <li>encerrar la definición de los campos entre llaves { }</li>
  <li>separar cada campo usando comas</li>
  <li>indicar el nombre y de qué tipo es cada campo</li>
</ul>

<pre>
  <code class="language-Haskell">data Pelicula = 
  UnaPelicula
    {tituloPelicula :: String ,
    directorPelicula :: String,
    actores :: [String],
    anioEstreno :: Int,
    puntajesPelicula :: [Int]}
    deriving (Show,Eq)
</code>
</pre>

<p>Con esta definición automaticamente Haskell define por nosotros las funciones tituloPelicula, puntajesPelicula, directorPelicula, actores y anioEstreno. El dominio de cada una de estas funciones es Pelicula y retornan lo que corresponda en cada caso.</p>

<p>Además cuando querramos obtener una nueva Película, podemos hacer</p>

<pre>
  <code class="language-Haskell">pulp = UnaPelicula "Pulp Fiction" "Quentin Tarantino" ["John Travolta", "Uma Thurman", "Samuel L. Jackson"] 1994 [9,10,9]
</code>
</pre>

<p>O bien podemos usar la siguiente notación que sólo es válida para datas definidos de esta forma. Como se puede ver, es más claro a que campo pertenece cada valor y no es necesario seguir un orden en los valores mientras se indique a que campo pertenece</p>

<pre>
  <code class="language-Haskell">pulp = 
  UnaPelicula {
    tituloPelicula = "Pulp Fiction",
    directorPelicula = "Quentin Tarantino",
    anioEstreno = 1994,
    puntajesPelicula = [9,10,9],
    actores = ["John Travolta", "Uma Thurman", "Samuel L. Jackson"]}
</code>
</pre>

<p>Esto ayuda mucho a la expresividad, pero también es más verboso. Uno tiene que evaluar cuándo vale la pena y cuándo no.</p>

<p>Otra cosa simpática de definir el data con sintaxis de registro es que que si el tipo deriva la typeclass Show, lo que se imprima en la consola cuando la expresión evaluada retorna algo de nuestro tipo (Pelicula en este caso) será más fácil de entender, porque mostrará cada valor asociado al nombre del campo en vez de uno al lado del otro, independientemente de qué notación se use para crear la película en cuestión.</p>

<p>Finalmente algo más que nos da esta forma de definir el data es un azúcar sintáctico para facilitar el <strong>copiado</strong> de datos, lo cual es particularmente útil para trabajar de forma <a href="inmutabilidad.html">inmutable</a>. Las siguientes definiciones son equivalentes:</p>
<pre>
  <code class="language-Haskell">agregarPuntaje nuevoPuntaje (UnaPelicula titulo director anio puntajes actores)
  = UnaPelicula titulo director anio (nuevoPuntaje : puntajes) actores
  
agregarPuntaje' nuevoPuntaje pelicula = pelicula { puntajesPelicula = nuevoPuntaje : puntajesPelicula pelicula }
</code>
</pre>

<p>En ambos casos lo que se está haciendo es crear una nueva película que tiene la misma información que la que se recibió por parámetro, excepto por los puntajes donde indicamos cuáles deberían ser los puntajes de la nueva película. De ninguna forma se modificarán los puntajes de pulp si consultamos <code class="language-plaintext highlighter-rouge">agregarPuntaje' 10 pulp</code>.</p>

<p>
  <strong>IMPORTANTE! Tengan en cuenta al usar este feature de copiado de ser cuidadosos y no abusar (al igual que no debería abusarse del pattern matching) porque un uso demasiado extendido atenta contra las abstracciones pequeñas y reutilizables. Funciones chiquitas y reutilizables matan sintaxis cheta.</strong>
</p>

<h1 id="tocAnchor-1-6">Cómo instanciar una typeclass</h1>

<p>Ya dijimos que a cada restricción se la conoce como typeclass. A cada tipo que pertenece a una typeclass se le debe definir una instancia de la misma.</p>

<p>Por ejemplo la clase Eq en algún lugar del Prelude (la biblioteca standard de Haskell) puede estar definida así:</p>

<pre>
  <code class="language-Haskell">-- Esto ya viene con Haskell
class Eq a where
  (==), (/=) :: a -&gt; a -&gt; Bool
-- Las instancias de Eq deben definir al menos una de estas 2 operaciones
  (/=) x y =  not (x == y)
  (==) x y =  not (x /= y)
</code>
</pre>

<p>Si decimos que el tipo Bool pertenece a la clase Eq escribimos</p>

<pre>
  <code class="language-Haskell">-- Esto ya viene con Haskell
instance Eq Bool where
  (==) True True = True
  (==) False False = True
  (==) _ _ = False
</code>
</pre>

<p>Otro ejemplo con la clase Ord</p>

<pre>
  <code class="language-Haskell">-- Notar que a tiene la restricción Eq en la definición de la clase Ord a
class Eq a =&gt; Ord a where
 (&lt;) :: a -&gt; a -&gt; Bool
 (&lt;=) :: a -&gt; a -&gt; Bool
 (&gt;) :: a -&gt; a -&gt; Bool
 (&gt;=) :: a -&gt; a -&gt; Bool
 max :: a -&gt; a -&gt; a
 min :: a -&gt; a -&gt; a
</code>
</pre>

<p>Si queremos hacer que el tipo Pelicula sea instancia de la clase Ord (por poner un ejemplo, definimos la función (&gt;) para que nos diga que una película es mayor que otra si su promedio de puntajes es mayor), podemos escribir:</p>

<pre>
  <code class="language-Haskell">instance Ord Pelicula where
  (&gt;) unaPelicula otraPelicula = promedio (puntajesPelicula unaPelicula) &gt; promedio (puntajesPelicula otraPelicula)
</code>
</pre>

<p>Por lo general es suficiente con derivar typclasses en nuestros data, pero es importante recordar que para poder hacer esto, todos los componentes del data a su vez deben pertenecer al typeclass que estamos derivando. Y si en algún momento nos pasa que tenemos un data que se compone, entre otras cosas, por alguna función, ya no vamos a poder derivar así como así Show y Eq que son las más usuales, porque las funciones no son ni Show ni Eq.</p>

<p>En esos casos podemos o bien optar porque nuestro data no sea Show o Eq, o bien definir un instance para esta typeclass que se corresponda con nuestro tipo de dato y así determinar nuestra propia solución a ese problema.</p>

<p>Supongamos que queremos mostrar a nuestros alumnos de una forma distinta, que nos muestre el nombre, las notas y además nos diga el estado de cursada (si aprobó o no en base a sus notas). Necesitamos agregar un instance para Show Alumno en vez de derivar Show. Por ejemplo:</p>

<pre>
  <code class="language-Haskell">instance Show Alumno where
  show (UnAlumno nombre notas) = show nombre ++ ": " ++ estadoDeCursada notas ++ " con " ++ show notas
 
estadoDeCursada notas
  | all aprobada notas = "CURSADA APROBADA"
  | otherwise = "CURSADA DESAPROBADA"
</code>
</pre>

<h1 id="tocAnchor-1-7">Múltiples constructores por tipo</h1>

<p>Supongamos que nos interesa saber la densidad de un cuerpo. Por ahora vamos a manejar cilindros (de los cuales sabemos su masa, su altura y el radio de su base), cubos (sólo conocemos su masa y el largo de alguno de sus lados) y esferas (de ellas se conoce su masa y su radio).</p>

<p>Para calcular la densidad de un cuerpo vamos a utilizar la siguiente fórmula: densidad = masa / volumen.</p>

<p>Arranquemos por declarar el tipo de dato para representar un cuerpo:</p>

<pre>
  <code class="language-Haskell">
data Cuerpo =
 Cilindro
   {masa :: Float,
   altura :: Float,
   radio :: Float} |
 Cubo
   {masa :: Float,
   lado :: Float} |
 Esfera
   {masa :: Float,
   radio :: Float}
 deriving (Show,Eq)
</code>
</pre>

<p>Podemos ver que el tipo Cuerpo incluye los constructores Cilindro, Cubo y Esfera. Como la fórmula de la densidad es igual para todos los cuerpos podemos escribir:</p>

<pre>
  <code class="language-Haskell">densidad unCuerpo = masa unCuerpo / volumen unCuerpo
</code>
</pre>

<p>Ahora bien, el cálculo del volumen es algo particular para cada cuerpo</p>

<pre>
  <code class="language-Haskell">volumen (Cilindro _ unaAltura unRadio) = pi * unRadio * unaAltura
volumen (Cubo _ unLado) = unLado ** 3
volumen (Esfera _ unRadio) = 4/3 * pi * (unRadio ** 3)
</code>
</pre>


</div>





<div id="article_metadata">
    <!-- <p><i>Latest update on July 31, 2018 by
        GitHub</i></p>

    <ul class="accordion" data-accordion>
        <li class="accordion-navigation">
            <a href="#panel1a">Page History, Meta information</a>

            <div id="panel1a" class="content">

                <div class="rows">
                    <div class="column small-12 medium-6 large-6">
                        <table>
                            <thead>
                            <tr>
                                <th>Page Commits</th>
                                <th>Page Additions</th>
                                <th>Page Deletions</th>
                            </tr>
                            </thead>

                            <tbody>
                            <tr>
                                <td>9</td>
                                <td>225</td>
                                <td>152</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>

                    <div class="column small-12 medium-6 large-6">
                        <table>
                            <thead>
                            <tr>
                                <th>Name</th>
                                <th>Email</th>
                                <th>Commits</th>
                            <tr>
                            </thead>

                            <tbody>
                            
                            <tr>
                                <td>Ernesto Bossi</td>
                                <td>bossi.e...</td>
                                <td>1</td>
                            </tr>
                            
                            <tr>
                                <td>Mariana</td>
                                <td>mmatos8...</td>
                                <td>5</td>
                            </tr>
                            
                            <tr>
                                <td>Mmatos</td>
                                <td>Mmatos@...</td>
                                <td>2</td>
                            </tr>
                            
                            <tr>
                                <td>asanzo</td>
                                <td>alfredo...</td>
                                <td>1</td>
                            </tr>
                            
                            </tbody>
                        </table>
                    </div>
                </div>

                <table style="margin-left: 15px;">
                    <thead>
                    <tr>
                        <th>Hash</th>
                        <th>Time</th>
                        <th>Name</th>
                        <th>Mail</th>
                        <th>Subject</th>
                    <tr>
                    </thead>

                    <tbody>
                    
                    <tr>
                        <td>792337d2</td>
                        <td>Tue Jul 31 17:05:45 2018 -0300</td>
                        <td>GitHub</td>
                        <td>noreply...</td>
                        <td>Update data--definiendo-nuestros-tipos-en-haskell.md</td>
                    </tr>
                    
                    <tr>
                        <td>aeb113bd</td>
                        <td>Tue Jul 31 17:03:56 2018 -0300</td>
                        <td>GitHub</td>
                        <td>noreply...</td>
                        <td>Update data--definiendo-nuestros-tipos-en-haskell.md</td>
                    </tr>
                    
                    <tr>
                        <td>8a902eb3</td>
                        <td>Tue Jul 31 16:47:15 2018 -0300</td>
                        <td>GitHub</td>
                        <td>noreply...</td>
                        <td>Update data--definiendo-nuestros-tipos-en-haskell.md</td>
                    </tr>
                    
                    <tr>
                        <td>0d01f485</td>
                        <td>Tue Jul 31 16:46:40 2018 -0300</td>
                        <td>GitHub</td>
                        <td>noreply...</td>
                        <td>Agrego ejemplo de instance Show</td>
                    </tr>
                    
                    <tr>
                        <td>d96ebfba</td>
                        <td>Tue Jul 31 16:34:20 2018 -0300</td>
                        <td>GitHub</td>
                        <td>noreply...</td>
                        <td>Update data--definiendo-nuestros-tipos-en-haskell.md</td>
                    </tr>
                    
                    </tbody>
                </table>

            </div>
        </li>
    </ul> -->

</div>


</div>


<div id="footer">
    <div class="columns small-12 medium-12 large-12">
        © 2025 - Uqbar Foundation
    </div>
</div>

<script>
    'use strict';
</script>

<script src="/assets/jquery-aa71a7b50270602be524223735204e4e.js"></script>
<script src="/assets/jquery.min-92bca385e77eff06fdfc99d71ff5d9cb.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js" type="text/javascript"></script>

<script src="/assets/foundation/foundation-9cdbe0bbce183118de08f9938e53d976.js"></script>
<script src="/assets/foundation/foundation.abide-89a2bdc8d7b0219f70b26edf2ae6887e.js"></script>
<script src="/assets/foundation/foundation.accordion-fb975cac4e1d51205357ccef64ad87f4.js"></script>
<script src="/assets/foundation/foundation.alert-09f0ede105a8181ae99c1e952f89ca3b.js"></script>
<script src="/assets/foundation/foundation.clearing-1720b58085d63e88f45a453bb9ad3e3b.js"></script>
<script src="/assets/foundation/foundation.dropdown-644acf98749f084fdf912c4b00957f31.js"></script>
<script src="/assets/foundation/foundation.equalizer-97288e933d9acc43fab592768c628ba6.js"></script>
<script src="/assets/foundation/foundation.interchange-083c4df6919a083e985b5e687d5c30b9.js"></script>
<script src="/assets/foundation/foundation.joyride-c8c49db46553294043e6ec5c19e1285b.js"></script>
<script src="/assets/foundation/foundation.magellan-2fb6e4d1e4284a920b3a7d892e2cb54c.js"></script>
<script src="/assets/foundation/foundation.offcanvas-63af9a0eca0822c6f6a77ba0eb3dd7ec.js"></script>
<script src="/assets/foundation/foundation.orbit-79b5540e0f58a265fd959aaf18fc2345.js"></script>
<script src="/assets/foundation/foundation.reveal-620cbbd491fb6eaf8dc057949a254e29.js"></script>
<script src="/assets/foundation/foundation.slider-e5da59a7bd13309d315a6a95e0654b35.js"></script>
<script src="/assets/foundation/foundation.tab-9ea3a242acf982f76f891ac5e32aa92a.js"></script>
<script src="/assets/foundation/foundation.tooltip-926551742e978e4456aa7ca8c6ffe334.js"></script>
<script src="/assets/foundation/foundation.topbar-fa936a3a88514cb2c51c4ccf3fefaeb0.js"></script>

<script src="/assets/jquery.cookie-600df63e64417ec0c172cd3580ffe4f3.js"></script>
<!-- Script pointing to jekyll-search.js -->
<script src="/assets/jekyll-search-db248d3bf113e122870c09fd6d9b0592.js"></script>

<script>
    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('results-container'),
        json: "/search.json"
    });

    $(document).foundation();

</script>

<!-- prism.js -->
<script src="/assets/prism-193ebecb65a347c425ecdb3c4592fd0e.js"></script>
</body>
</html>
